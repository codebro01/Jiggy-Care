================================================================================
                    JIGGY CARE CHAT SYSTEM DOCUMENTATION
                          FOR FRONTEND DEVELOPERS
================================================================================

Last Updated: 2026-02-16
Author: Backend Team
Purpose: Comprehensive guide for integrating the Jiggy Care chat system

================================================================================
TABLE OF CONTENTS
================================================================================
1. Overview
2. Server Configuration & Endpoints
3. WebSocket Implementation (Socket.IO)
4. REST API Endpoints
5. Data Models & DTOs
6. Authentication & Authorization
7. WebSocket Event Reference - Chat
8. WebSocket Event Reference - Video/Audio Calls
9. REST API Reference
10. Integration Examples
11. Error Handling
12. Best Practices
13. Troubleshooting

================================================================================
1. OVERVIEW
================================================================================

The Jiggy Care chat system is built using NestJS with Socket.IO for real-time
WebSocket communication and REST API endpoints for historical data retrieval.

Key Features:
- Real-time messaging between consultants and patients
- Message read receipts
- Typing indicators
- Conversation management
- Unread message counting
- Persistent message storage
- Video and audio calling with WebRTC
- Call signaling (initiate, accept, reject, end)
- Ringing notifications and auto-timeout

Tech Stack (Backend):
- NestJS (Node.js framework)
- Socket.IO (WebSocket library)
- PostgreSQL (via Drizzle ORM)
- JWT Authentication
- WebRTC Signaling

================================================================================
2. SERVER CONFIGURATION & ENDPOINTS
================================================================================

Production Server: https://jiggy-care.onrender.com
Local Development: http://localhost:3000

API Base Path: /api/v1
WebSocket Namespace: /chat

Full URLs:
-----------
REST API Base:
  - Production: https://jiggy-care.onrender.com/api/v1
  - Local: http://localhost:3000/api/v1

WebSocket Connection:
  - Production: https://jiggy-care.onrender.com/chat
  - Local: http://localhost:3000/chat

CORS Configuration:
-------------------
Allowed Origins:
  - http://localhost:3000
  - http://localhost:5173
  - https://jiggy-care.onrender.com

Credentials: Enabled
Methods: GET, HEAD, PUT, PATCH, POST, DELETE
Headers: Content-Type, Authorization, X-Access-Token, X-Refresh-Token, X-Client-Type

================================================================================
3. WEBSOCKET IMPLEMENTATION (Socket.IO)
================================================================================

CONNECTION DETAILS
------------------
WebSocket Gateway Configuration:
  - Namespace: /chat
  - CORS: Enabled (see above)
  - Transports: websocket, polling (fallback)

Connection URL Examples:
  - Production: wss://jiggy-care.onrender.com/chat
  - Local: ws://localhost:3000/chat

FRONTEND CONNECTION EXAMPLE (JavaScript/TypeScript)
---------------------------------------------------
import { io } from 'socket.io-client';

const socket = io('http://localhost:3000/chat', {
  transports: ['websocket', 'polling'],
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionAttempts: 5
});

socket.on('connect', () => {
  console.log('Connected to chat server:', socket.id);
});

socket.on('disconnect', () => {
  console.log('Disconnected from chat server');
});

socket.on('connect_error', (error) => {
  console.error('Connection error:', error);
});


CONNECTION LIFECYCLE
--------------------
1. Client connects to /chat namespace
2. Server logs connection with client socket ID
3. Client can join conversation rooms
4. Client sends/receives messages through rooms
5. Client can initiate/receive video and audio calls
6. On disconnect, client is removed from active users map

================================================================================
4. WEBSOCKET EVENT REFERENCE - CHAT
================================================================================

The WebSocket gateway supports the following real-time events:

EVENT 1: JOIN CONVERSATION (join_conversation)
-----------------------------------------------
Purpose: Join a specific conversation room to receive messages

Client Emits:
  socket.emit('join_conversation', {
    conversationId: 'uuid-of-conversation',
    userId: 'uuid-of-user',
    userType: 'consultant' | 'patient'
  });

Server Response:
  {
    event: 'joined_conversation',
    data: {
      conversationId: 'uuid-of-conversation'
    }
  }

Error Response:
  {
    event: 'error',
    data: {
      message: 'Missing required fields: conversationId, userId, or userType'
    }
  }

Notes:
- MUST be called before sending/receiving messages or initiating calls
- User is added to a Socket.IO room with the conversationId
- Server tracks active users in this conversation


EVENT 2: LEAVE CONVERSATION (leave_conversation)
-------------------------------------------------
Purpose: Leave a conversation room

Client Emits:
  socket.emit('leave_conversation', {
    conversationId: 'uuid-of-conversation'
  });

Server Response:
  {
    event: 'left_conversation',
    data: {
      conversationId: 'uuid-of-conversation'
    }
  }


EVENT 3: SEND MESSAGE (send_message)
-------------------------------------
Purpose: Send a new chat message

Client Emits:
  socket.emit('send_message', {
    conversationId: 'uuid-of-conversation',
    content: 'Hello, how are you?',
    senderType: 'consultant' | 'patient'
  });

Server Response (to sender):
  {
    event: 'message_sent',
    data: {
      message: {
        id: 'message-uuid',
        conversationId: 'conversation-uuid',
        senderId: 'sender-uuid',
        senderType: 'consultant',
        content: 'Hello, how are you?',
        isRead: false,
        createdAt: '2026-01-14T14:30:00Z',
        updatedAt: '2026-01-14T14:30:00Z'
      },
      conversation: {
        id: 'conversation-uuid',
        consultantId: 'consultant-uuid',
        patientId: 'patient-uuid',
        bookingId: 'booking-uuid',
        createdAt: '...',
        updatedAt: '...'
      }
    }
  }

Server Broadcasts (to all users in conversation):
  socket.on('new_message', (data) => {
    // Same structure as message_sent response
    console.log('New message received:', data);
  });

Error Response:
  {
    event: 'error',
    data: {
      message: 'Error description'
    }
  }

Notes:
- Message is saved to database
- All participants in the room receive 'new_message' event
- The conversationId must exist or will be auto-created based on booking


EVENT 4: TYPING INDICATORS (typing_start)
------------------------------------------
Purpose: Notify other users that someone is typing

Client Emits:
  socket.emit('typing_start', {
    conversationId: 'uuid-of-conversation',
    userId: 'uuid-of-user',
    userType: 'consultant' | 'patient'
  });

Other Clients Receive:
  socket.on('user_typing', (data) => {
    console.log(`${data.userId} is typing...`);
    // data: { userId: 'uuid', userType: 'consultant' }
  });

Notes:
- Does NOT broadcast to sender
- Use for showing "Typing..." indicator in UI


EVENT 5: TYPING STOP (typing_stop)
-----------------------------------
Purpose: Notify when user stops typing

Client Emits:
  socket.emit('typing_stop', {
    conversationId: 'uuid-of-conversation',
    userId: 'uuid-of-user'
  });

Other Clients Receive:
  socket.on('user_stopped_typing', (data) => {
    console.log(`${data.userId} stopped typing`);
    // data: { userId: 'uuid' }
  });


EVENT 6: MARK MESSAGES AS READ (mark_read)
-------------------------------------------
Purpose: Mark specific messages as read

Client Emits:
  socket.emit('mark_read', {
    conversationId: 'uuid-of-conversation',
    messageIds: ['msg-uuid-1', 'msg-uuid-2', 'msg-uuid-3']
  });

Server Response (to sender):
  {
    event: 'marked_as_read',
    data: {
      messageIds: ['msg-uuid-1', 'msg-uuid-2', 'msg-uuid-3'],
      success: true
    }
  }

Other Clients Receive:
  socket.on('messages_read', (data) => {
    console.log('Messages marked as read:', data.messageIds);
    // data: { conversationId: 'uuid', messageIds: [...] }
  });

Error Response:
  {
    event: 'error',
    data: {
      message: 'Invalid data provided'
    }
  }

Notes:
- Sender does NOT receive the 'messages_read' broadcast
- Updates database to set isRead = true
- Useful for read receipts/checkmarks in UI

================================================================================
5. WEBSOCKET EVENT REFERENCE - VIDEO/AUDIO CALLS
================================================================================

The chat system includes full support for video and audio calling using WebRTC.
The server handles call signaling, ringing notifications, and peer connection setup.

CALL LIFECYCLE OVERVIEW
------------------------
1. Caller initiates call → Server notifies recipient
2. Server starts ringing for both parties
3. Recipient accepts/rejects → Server notifies caller
4. WebRTC peer connection established (offer/answer/ICE)
5. Call in progress
6. Either party ends call → Server notifies other party

AUTO-TIMEOUT FEATURE
--------------------
- If recipient doesn't answer within 45 seconds:
  - Caller receives 'call:no-answer' event
  - Recipient receives 'call:missed' event
  - Ringing stops automatically


EVENT 1: INITIATE CALL (call:initiate)
---------------------------------------
Purpose: Start a video or audio call with another user

Client Emits:
  socket.emit('call:initiate', {
    toUserId: 'recipient-user-uuid',
    conversationId: 'conversation-uuid',
    callType: 'video' | 'audio'
  });

Server Responses:

1. To Caller (immediate):
  socket.on('call:ringing', (data) => {
    // data: { toUserId, conversationId, callType }
    // Play ringback tone for caller
  });

2. To Recipient:
  socket.on('call:incoming', (data) => {
    // data: { fromUserId, conversationId, callType }
    // Play incoming ringtone, show answer/decline UI
  });

3. If no answer after 45 seconds:
   - To Caller: socket.on('call:no-answer', { toUserId })
   - To Recipient: socket.on('call:missed', { fromUserId, conversationId })

Notes:
- Must join conversation first with join_conversation
- toUserId must be an active user in the system
- Auto-timeout is 45 seconds (configurable)


EVENT 2: RINGING NOTIFICATION (call:ringing)
---------------------------------------------
Purpose: Notify caller that ringing has started

Server Emits (to caller only):
  socket.on('call:ringing', (data) => {
    console.log('Call is ringing...');
    // data: { toUserId, conversationId, callType }
  });

Client Action:
  - Start playing ringback tone (for caller)
  - Show "Calling..." UI
  - Display cancel button

Audio Needed:
  - Ringback tone (different from incoming ringtone)


EVENT 3: INCOMING CALL (call:incoming)
---------------------------------------
Purpose: Notify recipient of an incoming call

Server Emits (to recipient only):
  socket.on('call:incoming', (data) => {
    console.log('Incoming call from:', data.fromUserId);
    // data: { fromUserId, conversationId, callType }
  });

Client Action:
  - Play incoming ringtone
  - Show full-screen call UI with:
    * Caller information
    * Accept button (green)
    * Decline button (red)
    * Call type indicator (video/audio)


EVENT 4: ACCEPT CALL (call:accept)
-----------------------------------
Purpose: Accept an incoming call

Client Emits:
  socket.emit('call:accept', {
    toUserId: 'caller-user-uuid'
  });

Server Responses:

1. To Recipient (who accepted):
  socket.on('call:connected', () => {
    // Stop incoming ringtone
    // Initialize WebRTC connection
  });

2. To Caller:
  socket.on('call:stop-ringing', () => {
    // Stop ringback tone
  });

  socket.on('call:accepted', (data) => {
    // data: { fromUserId }
    // Start WebRTC connection
  });

Notes:
- Automatically clears the 45-second timeout
- Both parties should now exchange WebRTC signals


EVENT 5: REJECT CALL (call:reject)
-----------------------------------
Purpose: Decline an incoming call

Client Emits:
  socket.emit('call:reject', {
    toUserId: 'caller-user-uuid',
    reason: 'Busy' // Optional, can be 'Busy', 'Declined', etc.
  });

Server Response (to caller):
  socket.on('call:rejected', (data) => {
    console.log('Call rejected:', data.reason);
    // data: { fromUserId, reason }
    // Stop ringing, show rejection message
  });

Notes:
- Automatically clears the 45-second timeout
- Caller sees rejection reason in UI


EVENT 6: NO ANSWER TIMEOUT (call:no-answer)
--------------------------------------------
Purpose: Notify caller that recipient didn't answer

Server Emits (to caller, after 45 seconds):
  socket.on('call:no-answer', (data) => {
    console.log('No answer from:', data.toUserId);
    // data: { toUserId }
  });

Client Action:
  - Stop ringback tone
  - Show "No answer" or "Unavailable" message
  - Close calling UI
  - Optionally log as missed call attempt


EVENT 7: MISSED CALL (call:missed)
-----------------------------------
Purpose: Notify recipient they missed a call

Server Emits (to recipient, after 45 seconds):
  socket.on('call:missed', (data) => {
    console.log('Missed call from:', data.fromUserId);
    // data: { fromUserId, conversationId }
  });

Client Action:
  - Stop incoming ringtone
  - Show missed call notification
  - Save to missed calls history/log
  - Show notification badge


EVENT 8: STOP RINGING (call:stop-ringing)
------------------------------------------
Purpose: Stop ringing tone when call is accepted

Server Emits (to caller when recipient accepts):
  socket.on('call:stop-ringing', () => {
    // Stop playing ringback tone
  });

Client Action:
  - Stop ringback audio
  - Prepare for call connection


EVENT 9: CALL CONNECTED (call:connected)
-----------------------------------------
Purpose: Confirm call connection to recipient

Server Emits (to recipient after accepting):
  socket.on('call:connected', () => {
    // Call is now connected
  });

Client Action:
  - Stop incoming ringtone
  - Show connected call UI
  - Start media streams


EVENT 10: END CALL (call:end)
------------------------------
Purpose: End an active call

Client Emits:
  socket.emit('call:end', {
    toUserId: 'other-user-uuid'
  });

Server Response (to other user):
  socket.on('call:ended', (data) => {
    console.log('Call ended by:', data.fromUserId);
    // data: { fromUserId }
  });

Client Action:
  - Close peer connection
  - Stop all media tracks
  - Clear call UI
  - Return to chat screen

Notes:
- Can be called by either party at any time
- Clears any active ringing timeouts


WEBRTC SIGNALING EVENTS
------------------------

EVENT 11: SEND WEBRTC OFFER (webrtc:offer)
-------------------------------------------
Purpose: Send WebRTC offer to establish peer connection

Client Emits (typically by caller):
  socket.emit('webrtc:offer', {
    toUserId: 'recipient-uuid',
    offer: RTCSessionDescription // SDP offer
  });

Server Forwards (to recipient):
  socket.on('webrtc:offer', (data) => {
    // data: { fromUserId, offer }
    // Use offer to create peer connection answer
  });


EVENT 12: SEND WEBRTC ANSWER (webrtc:answer)
---------------------------------------------
Purpose: Send WebRTC answer in response to offer

Client Emits (typically by recipient):
  socket.emit('webrtc:answer', {
    toUserId: 'caller-uuid',
    answer: RTCSessionDescription // SDP answer
  });

Server Forwards (to caller):
  socket.on('webrtc:answer', (data) => {
    // data: { fromUserId, answer }
    // Set remote description with answer
  });


EVENT 13: SEND ICE CANDIDATE (webrtc:ice-candidate)
----------------------------------------------------
Purpose: Exchange ICE candidates for NAT traversal

Client Emits (by both parties):
  socket.emit('webrtc:ice-candidate', {
    toUserId: 'other-user-uuid',
    candidate: RTCIceCandidateInit
  });

Server Forwards (to other party):
  socket.on('webrtc:ice-candidate', (data) => {
    // data: { fromUserId, candidate }
    // Add ICE candidate to peer connection
  });

Notes:
- Multiple ICE candidates may be exchanged
- Required for establishing connection through firewalls/NAT

================================================================================
6. REST API ENDPOINTS
================================================================================

All REST endpoints require JWT authentication.
Base URL: /api/v1/chat

Authentication Methods:
  1. Bearer Token (Mobile): Authorization: Bearer <token>
  2. Cookie (Web): access_token cookie
  3. Header: X-Client-Type: mobile | web

All endpoints require:
  - JWT authentication (JwtAuthGuard)
  - Role authorization (patient or consultant)


ENDPOINT 1: GET CONVERSATIONS
------------------------------
GET /api/v1/chat/conversations

Purpose: Retrieve all conversations for a user

Query Parameters:
  - consultantId (optional): UUID of consultant
  - patientId (optional): UUID of patient

Note: Must provide either consultantId OR patientId (not both)

Request Example:
  GET /api/v1/chat/conversations?patientId=abc-123-def

Headers:
  Authorization: Bearer <jwt-token>
  X-Client-Type: mobile

Response (200 OK):
  [
    {
      id: 'conversation-uuid',
      consultantId: 'consultant-uuid',
      patientId: 'patient-uuid',
      bookingId: 'booking-uuid',
      createdAt: '2026-01-14T12:00:00Z',
      updatedAt: '2026-01-14T14:30:00Z'
    },
    // ... more conversations
  ]

Error Responses:
  400 Bad Request: Missing consultantId or patientId
  401 Unauthorized: Invalid/missing JWT token
  403 Forbidden: User doesn't have required role


ENDPOINT 2: CREATE CONVERSATION
--------------------------------
POST /api/v1/chat/conversations

Purpose: Create a new conversation or get existing one

Request Body:
  {
    consultantId: 'consultant-uuid',
    patientId: 'patient-uuid',
    bookingId: 'booking-uuid'
  }

Headers:
  Authorization: Bearer <jwt-token>
  X-Client-Type: mobile
  Content-Type: application/json

Response (201 Created):
  {
    id: 'conversation-uuid',
    consultantId: 'consultant-uuid',
    patientId: 'patient-uuid',
    bookingId: 'booking-uuid',
    createdAt: '2026-01-14T12:00:00Z',
    updatedAt: '2026-01-14T12:00:00Z'
  }

Error Responses:
  400 Bad Request: Invalid UUID format or missing fields
  401 Unauthorized: Invalid/missing JWT token
  404 Not Found: Booking/consultant/patient not found


ENDPOINT 3: GET MESSAGES
-------------------------
GET /api/v1/chat/conversations/:conversationId/messages

Purpose: Retrieve message history for a conversation

Path Parameters:
  - conversationId: UUID of the conversation

Query Parameters:
  - limit (optional, default: 50): Number of messages to return
  - offset (optional, default: 0): Number of messages to skip (for pagination)

Request Example:
  GET /api/v1/chat/conversations/abc-123/messages?limit=20&offset=0

Headers:
  Authorization: Bearer <jwt-token>
  X-Client-Type: mobile

Response (200 OK):
  {
    conversation: {
      id: 'conversation-uuid',
      consultantId: 'consultant-uuid',
      patientId: 'patient-uuid',
      bookingId: 'booking-uuid',
      createdAt: '...',
      updatedAt: '...'
    },
    messages: [
      {
        id: 'message-uuid',
        conversationId: 'conversation-uuid',
        senderId: 'user-uuid',
        senderType: 'patient',
        content: 'Hello doctor',
        isRead: true,
        createdAt: '2026-01-14T12:00:00Z',
        updatedAt: '2026-01-14T12:00:00Z'
      },
      // ... more messages (newest first)
    ]
  }

Error Responses:
  404 Not Found: Conversation not found
  401 Unauthorized: Invalid/missing JWT token


ENDPOINT 4: SEND MESSAGE (REST)
--------------------------------
POST /api/v1/chat/messages

Purpose: Send a message via REST API (alternative to WebSocket)

Request Body:
  {
    consultantId: 'consultant-uuid',
    patientId: 'patient-uuid',
    bookingId: 'booking-uuid',
    content: 'Hello, I need help',
    senderType: 'patient' | 'consultant'
  }

Headers:
  Authorization: Bearer <jwt-token>
  X-Client-Type: mobile
  Content-Type: application/json

Response (201 Created):
  {
    message: {
      id: 'message-uuid',
      conversationId: 'conversation-uuid',
      senderId: 'sender-uuid',
      senderType: 'patient',
      content: 'Hello, I need help',
      isRead: false,
      createdAt: '2026-01-14T14:30:00Z',
      updatedAt: '2026-01-14T14:30:00Z'
    },
    conversation: {
      id: 'conversation-uuid',
      consultantId: 'consultant-uuid',
      patientId: 'patient-uuid',
      bookingId: 'booking-uuid',
      createdAt: '...',
      updatedAt: '...'
    }
  }

Error Responses:
  400 Bad Request: Missing required fields or invalid UUIDs
  401 Unauthorized: Invalid/missing JWT token


ENDPOINT 5: GET UNREAD COUNT
-----------------------------
GET /api/v1/chat/conversations/:conversationId/unread

Purpose: Get count of unread messages for a user in a conversation

Path Parameters:
  - conversationId: UUID of the conversation

Query Parameters:
  - userId: UUID of the user (required)

Request Example:
  GET /api/v1/chat/conversations/abc-123/unread?userId=user-456

Headers:
  Authorization: Bearer <jwt-token>
  X-Client-Type: mobile

Response (200 OK):
  {
    conversationId: 'abc-123',
    unreadCount: 5
  }

Error Responses:
  400 Bad Request: Missing userId
  401 Unauthorized: Invalid/missing JWT token


ENDPOINT 6: MARK MESSAGES AS READ (REST)
-----------------------------------------
POST /api/v1/chat/conversations/:conversationId/read

Purpose: Mark specific messages as read via REST API

Path Parameters:
  - conversationId: UUID of the conversation

Request Body:
  {
    messageIds: ['msg-uuid-1', 'msg-uuid-2', 'msg-uuid-3']
  }

Headers:
  Authorization: Bearer <jwt-token>
  X-Client-Type: mobile
  Content-Type: application/json

Response (200 OK):
  {
    success: true,
    updatedCount: 3
  }

Error Responses:
  400 Bad Request: Invalid messageIds
  404 Not Found: Conversation not found
  401 Unauthorized: Invalid/missing JWT token

================================================================================
7. DATA MODELS & DTOs
================================================================================

CONVERSATION MODEL
------------------
{
  id: string (UUID),
  consultantId: string (UUID),
  patientId: string (UUID),
  bookingId: string (UUID),
  createdAt: string (ISO 8601 datetime),
  updatedAt: string (ISO 8601 datetime)
}

MESSAGE MODEL
-------------
{
  id: string (UUID),
  conversationId: string (UUID),
  senderId: string (UUID),
  senderType: 'consultant' | 'patient',
  content: string,
  isRead: boolean,
  createdAt: string (ISO 8601 datetime),
  updatedAt: string (ISO 8601 datetime)
}

CREATE CONVERSATION DTO
-----------------------
{
  consultantId: string (UUID, required),
  patientId: string (UUID, required),
  bookingId: string (UUID, required)
}

CREATE MESSAGE DTO
------------------
{
  consultantId: string (UUID, required),
  patientId: string (UUID, required),
  bookingId: string (UUID, required),
  content: string (required, non-empty),
  senderType: 'consultant' | 'patient' (required)
}

CALL INITIATE DTO
-----------------
{
  toUserId: string (UUID, required),
  conversationId: string (UUID, required),
  callType: 'video' | 'audio' (required)
}

WEBRTC SIGNAL DTOs
------------------
Offer/Answer:
{
  toUserId: string (UUID, required),
  offer/answer: RTCSessionDescriptionInit
}

ICE Candidate:
{
  toUserId: string (UUID, required),
  candidate: RTCIceCandidateInit
}

================================================================================
8. AUTHENTICATION & AUTHORIZATION
================================================================================

AUTH REQUIREMENTS
-----------------
All REST endpoints require:
  1. Valid JWT token (either in Authorization header or cookie)
  2. User role must be 'patient' or 'consultant'

WebSocket connections:
  - Currently no authentication on connection
  - Events validate conversationId and userId
  - Future: Implement JWT handshake on connection

HEADERS FOR MOBILE CLIENTS
---------------------------
Authorization: Bearer <your-jwt-token>
X-Client-Type: mobile

HEADERS FOR WEB CLIENTS
-----------------------
Cookie: access_token=<your-jwt-token>
X-Client-Type: web

OBTAINING JWT TOKEN
-------------------
Use the authentication endpoints (not covered in this doc):
  POST /api/v1/auth/login
  POST /api/v1/auth/register

Store the token for subsequent requests.

================================================================================
9. INTEGRATION EXAMPLES
================================================================================

EXAMPLE 1: COMPLETE CHAT FLOW WITH VIDEO CALLING (React/TypeScript)
--------------------------------------------------------------------

import { io, Socket } from 'socket.io-client';
import axios from 'axios';

const API_BASE = 'http://localhost:3000/api/v1';
const SOCKET_URL = 'http://localhost:3000/chat';

class ChatService {
  private socket: Socket | null = null;
  private token: string;
  private peerConnection: RTCPeerConnection | null = null;
  private localStream: MediaStream | null = null;
  private remoteStream: MediaStream | null = null;

  constructor(token: string) {
    this.token = token;
  }

  // Initialize WebSocket connection
  connect(userId: string, userType: 'patient' | 'consultant') {
    this.socket = io(SOCKET_URL, {
      transports: ['websocket', 'polling'],
    });

    this.socket.on('connect', () => {
      console.log('Connected:', this.socket?.id);
    });

    // Chat event listeners
    this.socket.on('new_message', (data) => {
      console.log('New message:', data);
      // Update UI with new message
    });

    this.socket.on('messages_read', (data) => {
      console.log('Messages read:', data);
      // Update UI to show read receipts
    });

    this.socket.on('user_typing', (data) => {
      console.log('User typing:', data);
      // Show typing indicator
    });

    this.socket.on('user_stopped_typing', (data) => {
      console.log('User stopped typing');
      // Hide typing indicator
    });

    // Call event listeners
    this.setupCallListeners();
  }

  // Setup all call-related event listeners
  private setupCallListeners() {
    // Ringing started (caller side)
    this.socket?.on('call:ringing', (data) => {
      console.log('Call is ringing...');
      this.playRingbackTone();
      // Show "Calling..." UI
    });

    // Incoming call (recipient side)
    this.socket?.on('call:incoming', (data) => {
      console.log('Incoming call from:', data.fromUserId);
      this.playIncomingRingtone();
      // Show answer/decline UI
    });

    // Call accepted
    this.socket?.on('call:accepted', (data) => {
      console.log('Call accepted');
      this.stopRingbackTone();
      // Start WebRTC connection as caller
    });

    // Stop ringing
    this.socket?.on('call:stop-ringing', () => {
      this.stopRingbackTone();
    });

    // Call connected (recipient confirmation)
    this.socket?.on('call:connected', () => {
      console.log('Call connected');
      this.stopIncomingRingtone();
      // Start WebRTC connection as recipient
    });

    // Call rejected
    this.socket?.on('call:rejected', (data) => {
      console.log('Call rejected:', data.reason);
      this.stopRingbackTone();
      this.cleanup();
      // Show rejection message
    });

    // No answer timeout
    this.socket?.on('call:no-answer', (data) => {
      console.log('No answer');
      this.stopRingbackTone();
      this.cleanup();
      // Show "No answer" message
    });

    // Missed call notification
    this.socket?.on('call:missed', (data) => {
      console.log('Missed call from:', data.fromUserId);
      this.stopIncomingRingtone();
      // Show missed call notification
    });

    // Call ended
    this.socket?.on('call:ended', (data) => {
      console.log('Call ended by:', data.fromUserId);
      this.endCall();
    });

    // WebRTC signaling
    this.setupWebRTCListeners();
  }

  // WebRTC signaling listeners
  private setupWebRTCListeners() {
    this.socket?.on('webrtc:offer', async (data) => {
      console.log('Received offer');
      await this.handleOffer(data.offer, data.fromUserId);
    });

    this.socket?.on('webrtc:answer', async (data) => {
      console.log('Received answer');
      await this.handleAnswer(data.answer);
    });

    this.socket?.on('webrtc:ice-candidate', async (data) => {
      console.log('Received ICE candidate');
      await this.handleIceCandidate(data.candidate);
    });
  }

  // Join a conversation
  joinConversation(conversationId: string, userId: string, userType: string) {
    this.socket?.emit('join_conversation', {
      conversationId,
      userId,
      userType
    });
  }

  // Send a message
  sendMessage(conversationId: string, content: string, senderType: string) {
    this.socket?.emit('send_message', {
      conversationId,
      content,
      senderType
    });
  }

  // Typing indicators
  startTyping(conversationId: string, userId: string, userType: string) {
    this.socket?.emit('typing_start', {
      conversationId,
      userId,
      userType
    });
  }

  stopTyping(conversationId: string, userId: string) {
    this.socket?.emit('typing_stop', {
      conversationId,
      userId
    });
  }

  // Mark messages as read
  markAsRead(conversationId: string, messageIds: string[]) {
    this.socket?.emit('mark_read', {
      conversationId,
      messageIds
    });
  }

  // CALL FUNCTIONS

  // Initiate a call
  async initiateCall(
    toUserId: string,
    conversationId: string,
    callType: 'video' | 'audio'
  ) {
    // Get local media stream
    await this.setupLocalMedia(callType);

    // Emit call initiation
    this.socket?.emit('call:initiate', {
      toUserId,
      conversationId,
      callType
    });

    // Create peer connection and send offer
    await this.createPeerConnection(toUserId);
    await this.createAndSendOffer(toUserId);
  }

  // Accept incoming call
  async acceptCall(callerId: string, callType: 'video' | 'audio') {
    // Get local media stream
    await this.setupLocalMedia(callType);

    // Emit call acceptance
    this.socket?.emit('call:accept', {
      toUserId: callerId
    });

    // Peer connection will be created when offer is received
  }

  // Reject incoming call
  rejectCall(callerId: string, reason: string = 'Busy') {
    this.socket?.emit('call:reject', {
      toUserId: callerId,
      reason
    });
    this.stopIncomingRingtone();
  }

  // End active call
  endCall() {
    if (this.peerConnection) {
      this.peerConnection.close();
      this.peerConnection = null;
    }

    if (this.localStream) {
      this.localStream.getTracks().forEach(track => track.stop());
      this.localStream = null;
    }

    this.remoteStream = null;
    // Notify UI to close call screen
  }

  // WEBRTC FUNCTIONS

  private async setupLocalMedia(callType: 'video' | 'audio') {
    try {
      this.localStream = await navigator.mediaDevices.getUserMedia({
        video: callType === 'video',
        audio: true
      });
      // Attach to UI video element
      console.log('Local media setup complete');
    } catch (error) {
      console.error('Failed to get media:', error);
      throw error;
    }
  }

  private async createPeerConnection(remoteUserId: string) {
    const config: RTCConfiguration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    this.peerConnection = new RTCPeerConnection(config);

    // Add local tracks
    this.localStream?.getTracks().forEach(track => {
      this.peerConnection?.addTrack(track, this.localStream!);
    });

    // Handle remote stream
    this.peerConnection.ontrack = (event) => {
      this.remoteStream = event.streams[0];
      // Attach to UI video element
      console.log('Remote stream received');
    };

    // Handle ICE candidates
    this.peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        this.socket?.emit('webrtc:ice-candidate', {
          toUserId: remoteUserId,
          candidate: event.candidate
        });
      }
    };
  }

  private async createAndSendOffer(remoteUserId: string) {
    if (!this.peerConnection) return;

    const offer = await this.peerConnection.createOffer();
    await this.peerConnection.setLocalDescription(offer);

    this.socket?.emit('webrtc:offer', {
      toUserId: remoteUserId,
      offer
    });
  }

  private async handleOffer(offer: RTCSessionDescriptionInit, fromUserId: string) {
    await this.createPeerConnection(fromUserId);
    
    if (!this.peerConnection) return;

    await this.peerConnection.setRemoteDescription(offer);
    const answer = await this.peerConnection.createAnswer();
    await this.peerConnection.setLocalDescription(answer);

    this.socket?.emit('webrtc:answer', {
      toUserId: fromUserId,
      answer
    });
  }

  private async handleAnswer(answer: RTCSessionDescriptionInit) {
    if (!this.peerConnection) return;
    await this.peerConnection.setRemoteDescription(answer);
  }

  private async handleIceCandidate(candidate: RTCIceCandidateInit) {
    if (!this.peerConnection) return;
    await this.peerConnection.addIceCandidate(candidate);
  }

  // AUDIO MANAGEMENT

  private ringbackAudio: HTMLAudioElement | null = null;
  private incomingAudio: HTMLAudioElement | null = null;

  private playRingbackTone() {
    this.ringbackAudio = new Audio('/sounds/ringback.mp3');
    this.ringbackAudio.loop = true;
    this.ringbackAudio.play().catch(err => {
      console.error('Failed to play ringback:', err);
    });
  }

  private stopRingbackTone() {
    if (this.ringbackAudio) {
      this.ringbackAudio.pause();
      this.ringbackAudio.currentTime = 0;
      this.ringbackAudio = null;
    }
  }

  private playIncomingRingtone() {
    this.incomingAudio = new Audio('/sounds/incoming.mp3');
    this.incomingAudio.loop = true;
    this.incomingAudio.play().catch(err => {
      console.error('Failed to play incoming ringtone:', err);
    });
  }

  private stopIncomingRingtone() {
    if (this.incomingAudio) {
      this.incomingAudio.pause();
      this.incomingAudio.currentTime = 0;
      this.incomingAudio = null;
    }
  }

  private cleanup() {
    this.stopRingbackTone();
    this.stopIncomingRingtone();
    this.endCall();
  }

  // REST API METHODS

  // Fetch conversation history (REST)
  async getMessages(conversationId: string, limit = 50, offset = 0) {
    const response = await axios.get(
      `${API_BASE}/chat/conversations/${conversationId}/messages`,
      {
        params: { limit, offset },
        headers: {
          Authorization: `Bearer ${this.token}`,
          'X-Client-Type': 'mobile'
        }
      }
    );
    return response.data;
  }

  // Get all conversations (REST)
  async getConversations(userId: string, userType: 'patient' | 'consultant') {
    const queryParam = userType === 'patient' ? 'patientId' : 'consultantId';
    const response = await axios.get(
      `${API_BASE}/chat/conversations?${queryParam}=${userId}`,
      {
        headers: {
          Authorization: `Bearer ${this.token}`,
          'X-Client-Type': 'mobile'
        }
      }
    );
    return response.data;
  }

  // Create conversation (REST)
  async createConversation(
    consultantId: string,
    patientId: string,
    bookingId: string
  ) {
    const response = await axios.post(
      `${API_BASE}/chat/conversations`,
      { consultantId, patientId, bookingId },
      {
        headers: {
          Authorization: `Bearer ${this.token}`,
          'X-Client-Type': 'mobile'
        }
      }
    );
    return response.data;
  }

  // Disconnect
  disconnect() {
    this.cleanup();
    this.socket?.disconnect();
  }
}

// Usage:
const chatService = new ChatService('your-jwt-token');
chatService.connect('user-uuid', 'patient');
chatService.joinConversation('conv-uuid', 'user-uuid', 'patient');

// Send message
chatService.sendMessage('conv-uuid', 'Hello!', 'patient');

// Start video call
chatService.initiateCall('recipient-uuid', 'conv-uuid', 'video');


EXAMPLE 2: REACT NATIVE USAGE WITH CALLS
-----------------------------------------

import { io } from 'socket.io-client';
import { RTCPeerConnection, mediaDevices } from 'react-native-webrtc';

const ChatScreen = ({ conversationId, userId, userType, token }) => {
  const [messages, setMessages] = useState([]);
  const [socket, setSocket] = useState(null);
  const [incomingCall, setIncomingCall] = useState(null);
  const [activeCall, setActiveCall] = useState(null);

  useEffect(() => {
    // Connect to WebSocket
    const newSocket = io('http://localhost:3000/chat', {
      transports: ['websocket', 'polling'],
    });

    newSocket.on('connect', () => {
      // Join conversation
      newSocket.emit('join_conversation', {
        conversationId,
        userId,
        userType
      });
    });

    newSocket.on('new_message', (data) => {
      setMessages(prev => [...prev, data.message]);
    });

    // Call events
    newSocket.on('call:incoming', (data) => {
      setIncomingCall(data);
      // Play ringtone
    });

    newSocket.on('call:accepted', () => {
      // Start WebRTC connection
      setActiveCall({ status: 'connecting' });
    });

    newSocket.on('call:rejected', (data) => {
      Alert.alert('Call Rejected', data.reason);
      setActiveCall(null);
    });

    newSocket.on('call:ended', () => {
      setActiveCall(null);
      // Clean up peer connection
    });

    setSocket(newSocket);

    return () => {
      newSocket.emit('leave_conversation', { conversationId });
      newSocket.disconnect();
    };
  }, [conversationId]);

  const startVideoCall = (recipientId) => {
    socket?.emit('call:initiate', {
      toUserId: recipientId,
      conversationId,
      callType: 'video'
    });
    setActiveCall({ status: 'calling', recipientId });
  };

  const acceptCall = () => {
    socket?.emit('call:accept', {
      toUserId: incomingCall.fromUserId
    });
    setIncomingCall(null);
    setActiveCall({ status: 'connecting' });
  };

  const rejectCall = () => {
    socket?.emit('call:reject', {
      toUserId: incomingCall.fromUserId,
      reason: 'Declined'
    });
    setIncomingCall(null);
  };

  const endCall = () => {
    socket?.emit('call:end', {
      toUserId: activeCall.recipientId
    });
    setActiveCall(null);
    // Clean up media
  };

  // ... rest of component
};


EXAMPLE 3: PAGINATION FOR MESSAGE HISTORY
------------------------------------------

async function loadMessages(conversationId, page = 1, pageSize = 20) {
  const offset = (page - 1) * pageSize;
  
  const response = await fetch(
    `http://localhost:3000/api/v1/chat/conversations/${conversationId}/messages?limit=${pageSize}&offset=${offset}`,
    {
      headers: {
        'Authorization': `Bearer ${token}`,
        'X-Client-Type': 'mobile'
      }
    }
  );
  
  const data = await response.json();
  return data.messages;
}

// Load first page
const page1 = await loadMessages('conv-uuid', 1);

// Load second page
const page2 = await loadMessages('conv-uuid', 2);

================================================================================
10. ERROR HANDLING
================================================================================

COMMON ERROR SCENARIOS
----------------------

1. Connection Errors (WebSocket)
   - Server down
   - Network issues
   - Invalid URL

   Handle with:
   socket.on('connect_error', (error) => {
     console.error('Connection failed:', error);
     // Show offline mode or retry
   });

2. Authentication Errors (REST)
   - 401 Unauthorized: Invalid/expired token
   - 403 Forbidden: User doesn't have permission

   Handle with:
   - Redirect to login
   - Refresh token
   - Show error message

3. Validation Errors
   - 400 Bad Request: Invalid data format
   - Missing required fields
   - Invalid UUIDs

   Handle with:
   - Validate data before sending
   - Show user-friendly error messages

4. Not Found Errors
   - 404: Conversation/message doesn't exist

   Handle with:
   - Sync local state with server
   - Create conversation if needed

5. WebSocket Event Errors
   - Server returns { event: 'error', data: { message: '...' } }

   Handle with:
   socket.on('error', (data) => {
     console.error('Server error:', data.message);
     // Show error to user
   });

6. WebRTC Errors
   - Media permission denied
   - Peer connection failed
   - ICE connection failure

   Handle with:
   - Check browser permissions
   - Show user-friendly error
   - Provide fallback to audio-only
   - Retry connection

7. Call Errors
   - User not found/offline
   - No answer timeout
   - Connection quality issues

   Handle with:
   - Show appropriate UI message
   - Cleanup resources
   - Log for debugging

ERROR RESPONSE FORMATS
----------------------

REST API Error:
{
  statusCode: 400,
  message: 'Validation failed',
  error: 'Bad Request'
}

WebSocket Error:
{
  event: 'error',
  data: {
    message: 'Error description'
  }
}

================================================================================
11. BEST PRACTICES
================================================================================

CHAT BEST PRACTICES
-------------------

1. CONNECTION MANAGEMENT
   - Connect once when user enters chat
   - Disconnect when leaving chat screen
   - Handle reconnection automatically
   - Store socket instance in context/service

2. ROOM MANAGEMENT
   - Join conversation room before sending messages or calls
   - Leave room when exiting chat screen
   - Join multiple rooms for multiple conversations

3. MESSAGE SENDING
   - Use WebSocket for real-time messages
   - Use REST as fallback if WebSocket unavailable
   - Show optimistic UI updates
   - Handle message failures gracefully

4. MESSAGE LOADING
   - Load initial messages via REST API
   - Use WebSocket for new messages
   - Implement pagination for old messages
   - Cache messages locally

5. READ RECEIPTS
   - Mark messages as read when user views them
   - Use WebSocket for real-time read updates
   - Debounce read status updates

6. TYPING INDICATORS
   - Send typing_start when user starts typing
   - Send typing_stop after 2-3 seconds of inactivity
   - Debounce typing events to avoid spam

VIDEO CALL BEST PRACTICES
--------------------------

1. CALL INITIATION
   - Check media permissions before initiating call
   - Show clear UI feedback (calling, ringing, connecting)
   - Provide cancel option during ringing
   - Handle rejection gracefully

2. CALL ACCEPTANCE
   - Show full-screen incoming call UI
   - Play appropriate ringtone
   - Provide accept/decline buttons
   - Show caller information

3. WEBRTC CONNECTION
   - Use STUN/TURN servers for NAT traversal
   - Handle ICE connection states
   - Implement reconnection logic
   - Monitor connection quality

4. MEDIA MANAGEMENT
   - Request permissions early
   - Handle denied permissions gracefully
   - Provide mute/unmute controls
   - Stop tracks on call end

5. CALL QUALITY
   - Monitor network conditions
   - Show connection quality indicator
   - Provide audio-only fallback
   - Handle bandwidth constraints

6. CLEANUP
   - Always stop media tracks on call end
   - Close peer connections properly
   - Clear timers and listeners
   - Reset UI state

GENERAL BEST PRACTICES
-----------------------

7. PERFORMANCE
   - Limit message history loaded at once
   - Implement virtual scrolling for long conversations
   - Cleanup listeners on component unmount
   - Throttle real-time events
   - Reuse peer connections when possible

8. SECURITY
   - Never expose JWT token in URLs
   - Validate user permissions on client
   - Sanitize message content (prevent XSS)
   - Use HTTPS/WSS in production
   - Encrypt media streams

9. OFFLINE SUPPORT
   - Queue messages when offline
   - Sync when connection restored
   - Show offline indicator
   - Store messages locally
   - Handle call failures due to network

10. USER EXPERIENCE
    - Show loading states
    - Display connection status
    - Handle errors gracefully
    - Provide retry mechanisms
    - Show toast/notification for new messages
    - Provide call history
    - Show missed call badges

11. AUDIO/RINGTONES
    - Use distinct tones for caller vs recipient
    - Support volume control
    - Handle audio focus properly
    - Stop all audio on cleanup
    - Test on actual devices (not just emulator)

12. TESTING
    - Test on real devices with various networks
    - Test peer-to-peer scenarios
    - Test network interruptions
    - Test permission denial scenarios
    - Test multiple simultaneous calls

================================================================================
12. TROUBLESHOOTING
================================================================================

CHAT ISSUES
-----------

ISSUE: WebSocket won't connect
SOLUTION:
  - Check server is running
  - Verify correct URL (include /chat namespace)
  - Check CORS configuration
  - Try polling transport first
  - Check browser/app network logs

ISSUE: Messages not appearing in real-time
SOLUTION:
  - Ensure you've joined the conversation room
  - Check event listeners are registered
  - Verify conversationId is correct
  - Check server logs for errors

ISSUE: Authentication failing
SOLUTION:
  - Verify JWT token is valid and not expired
  - Check Authorization header format
  - Include X-Client-Type header
  - Check user has correct role (patient/consultant)

ISSUE: Can't mark messages as read
SOLUTION:
  - Verify messageIds are valid UUIDs
  - Ensure conversationId is correct
  - Check user is participant in conversation
  - Use REST endpoint as fallback

ISSUE: Duplicate messages appearing
SOLUTION:
  - Deduplicate by message ID
  - Don't add message if already in list
  - Check for multiple WebSocket connections

CALL ISSUES
-----------

ISSUE: Call not connecting
SOLUTION:
  - Check both users are online and connected
  - Verify userId mapping is correct
  - Check WebRTC peer connection state
  - Verify STUN servers are reachable
  - Check browser WebRTC support

ISSUE: No audio/video
SOLUTION:
  - Check media permissions granted
  - Verify correct media constraints
  - Check microphone/camera hardware
  - Test with browser DevTools
  - Check if tracks are added to peer connection

ISSUE: Ringing not heard
SOLUTION:
  - Check audio files exist and are accessible
  - Verify audio element creation
  - Check browser autoplay policy
  - Test with user interaction first
  - Check volume settings

ISSUE: Call drops immediately
SOLUTION:
  - Check ICE connection state
  - Verify STUN/TURN configuration
  - Check firewall/NAT settings
  - Monitor peer connection events
  - Check network stability

ISSUE: One-way audio/video
SOLUTION:
  - Verify both users added tracks
  - Check remote stream handling
  - Verify track directions (sendrecv)
  - Check ICE candidates exchange
  - Test with simpler network setup

ISSUE: Call timeout not working
SOLUTION:
  - Check server logs for timeout events
  - Verify 45-second timer is running
  - Check event listeners are registered
  - Verify userId is correct in events

ISSUE: Can't initiate call
SOLUTION:
  - Ensure user joined conversation first
  - Check toUserId exists and is online
  - Verify conversationId is valid
  - Check for active ringing timeout from previous call

DEBUGGING TIPS
--------------

1. WebSocket Debugging:
   - Use browser DevTools Network tab (WS filter)
   - Log all socket events with timestamps
   - Monitor socket.connected state
   - Check for event name typos

2. WebRTC Debugging:
   - Use chrome://webrtc-internals (Chrome)
   - Monitor peer connection state changes
   - Log ICE connection states
   - Check candidate gathering
   - Verify SDP offer/answer exchange

3. Audio Debugging:
   - Check browser console for audio errors
   - Verify file paths are correct
   - Test audio play with user interaction
   - Check audio element state
   - Test on actual device (not just emulator)

4. General Debugging:
   - Enable verbose logging
   - Use unique IDs for tracking
   - Test with two separate browsers/devices
   - Check server logs concurrently
   - Use network throttling to test edge cases

================================================================================
CONFIGURATION NOTES
================================================================================

TIMEOUT CONFIGURATION
---------------------
The call ringing timeout is set to 45 seconds. To modify:

// In backend chat.gateway.ts
const ringingTimeout = setTimeout(() => {
  // ... timeout logic
}, 45000); // Change this value (milliseconds)

WEBRTC CONFIGURATION
--------------------
ICE Servers (modify in your client code):

const config: RTCConfiguration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    // Add TURN servers for production:
    // {
    //   urls: 'turn:your-turn-server.com:3478',
    //   username: 'username',
    //   credential: 'password'
    // }
  ]
};

AUDIO FILES
-----------
Place these audio files in your public assets:
- /sounds/ringback.mp3 - Caller ringing tone
- /sounds/incoming.mp3 - Recipient incoming call tone

================================================================================
SUPPORT & CONTACT
================================================================================

For questions or issues, contact:
  Backend Team: [Your contact info]
  
API Documentation (Swagger):
  http://localhost:3000/api/v1/api-docs
  https://jiggy-care.onrender.com/api/v1/api-docs

GitHub Repository: [Your repo]

================================================================================
QUICK REFERENCE - CALL EVENTS SUMMARY
================================================================================

CALLER EVENTS (Outgoing Call):
1. Emit: call:initiate
2. Listen: call:ringing (start ringback tone)
3. Listen: call:accepted OR call:rejected OR call:no-answer
4. Listen: call:stop-ringing (stop ringback)
5. Listen: webrtc:answer (complete connection)
6. Emit: call:end (to end call)

RECIPIENT EVENTS (Incoming Call):
1. Listen: call:incoming (play incoming ringtone)
2. Emit: call:accept OR call:reject
3. Listen: call:connected (stop ringtone)
4. Listen: webrtc:offer (start connection)
5. Emit: webrtc:answer (respond to offer)
6. Listen: call:ended (other party hung up)

WEBRTC SIGNAL FLOW:
Caller → offer → Recipient
Recipient → answer → Caller
Both ↔ ice-candidate ↔ Both (multiple times)

================================================================================
END OF DOCUMENTATION
================================================================================